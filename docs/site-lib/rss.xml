<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Secure Store]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Secure Store</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 10 Dec 2025 03:01:40 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 10 Dec 2025 03:01:39 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Secure Store]]></title><description><![CDATA[<img src="assets/secure-store.png" target="_self">]]></description><link>assets/secure-store.html</link><guid isPermaLink="false">Assets/Secure Store.png</guid><pubDate>Wed, 10 Dec 2025 03:01:08 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3. Notes And Security]]></title><description><![CDATA[This page exists because “secure” is a loaded word. Here’s the unfiltered truth about what Secure Store actually protects, and what it deliberately does not try to do.Secure Store is not the final security boundary. It’s the hand-off layer.<a data-tooltip-position="top" aria-label="https://github.com/Walker-Industries-RnD/Plagues-Protocol" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/Walker-Industries-RnD/Plagues-Protocol" target="_self">Secure Store Was Originally Made For Plague Worker</a>Here’s how it actually gets used in production:
Untrusted UI process (your app, plugins, shell) launches.
It needs to talk to a privileged Plagues Worker running as SYSTEM/root.
<br>The worker starts first (at login), generates a random local gRPC endpoint (e.g. <a rel="noopener nofollow" class="external-link is-unresolved" href="http://127.0.0.1:5057" target="_self">http://127.0.0.1:5057</a>), and writes it to Secure Store with SecureStore.Set("worker_addr", endpoint).
The untrusted UI later does SecureStore.Get("worker_addr") → connects → now all real secrets live only inside the signed, manifest-verified, privileged worker.
Secure Store never holds anything truly sensitive longer than a few seconds.
Result: Even if the entire userland is compromised, the attacker only ever learns a temporary local port number — which is useless without also compromising the Plagues Worker (which self-verifies its own executable + all DLLs with Kyber-signed Blake3 manifests before listening).Secure Store = “secure enough to survive until the real fortress (Plagues Worker) wakes up”.That’s by design. Small, auditable, zero dependencies, works everywhere. Anything more belongs behind the cryptographically-sealed boundary of a Plague Worker.]]></description><link>3.-notes-and-security.html</link><guid isPermaLink="false">3. Notes And Security.md</guid><pubDate>Wed, 10 Dec 2025 02:53:21 GMT</pubDate></item><item><title><![CDATA[1. Welcome]]></title><description><![CDATA[ <img alt="Secure Store" src="assets/secure-store.png" referrerpolicy="no-referrer" target="_self" style="max-width: 100%;"> A tiny, cross-platform, fully local, per-user encrypted-at-rest secure key/value store that only the current logged-in user can read or write. Secure Store is the minimalist storage backend used throughout the XRUIOS to safely persist sensitive data (API endpoints, tokens, session keys, etc.) with zero external dependencies and strong filesystem-level isolation. It was created during a need to implement cross platform variables that would be secure, not easily tamperable and able to be easily referenced (Or an alternative to EnvironmentVariableTarget.User) Windows • Linux • macOS • 100% Offline • No Registry • No Keychain • Pure .NET 8 • Post-Quantum Ready
Secure Store writes serialized JSON files into a private runtime directory that is automatically cleaned up on logout/reboot where possible:
Files are named xr_&lt;key&gt;.dat
Data is serialized with System.Text.Json (UTF-8, no encryption at rest yet — relies on filesystem isolation)
On Windows: inheritance is disabled and an explicit Allow rule is set for the current user SID only
On Unix: chmod 600 is invoked via /bin/chmod; if that fails it falls back to marking the file hidden (best-effort)
Zero trust against other local users or compromised processes running as different accounts “If another local user or malware without your exact user context can read it — it’s not secure.”
<br> <a href="https://github.com/Walker-Industries-RnD/Secure-Store" target="_self" rel="noopener nofollow" class="is-unresolved"><strong></strong></a>View on GitHub • <a href="https://walkerindustries.xyz" target="_self" rel="noopener nofollow" class="is-unresolved">Walker Industries</a> • <a href="https://discord.gg/H8h8scsxtH" target="_self" rel="noopener nofollow" class="is-unresolved">Discord</a> • <a href="https://www.patreon.com/walkerdev" target="_self" rel="noopener nofollow" class="is-unresolved">Patreon</a> Full source is deliberately &lt;150 lines. You can audit it in 30 seconds.
Secure Store is stupid simple to use;using Secure_Store; // Save anything serializable
SecureStore.Set("worker_addr", "http://localhost:5050");
SecureStore.Set("last_session", new SessionData { User = "walker", Expires = DateTime.UtcNow.AddHours(8) }); // Read it back
string? addr = SecureStore.Get&lt;string&gt;("worker_addr");
var session = SecureStore.Get&lt;SessionData&gt;("last_session"); // Works with complex objects too
public record SessionData(string User, DateTime Expires); ]]></description><link>1.-welcome.html</link><guid isPermaLink="false">1. Welcome.md</guid><pubDate>Wed, 10 Dec 2025 02:50:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2. How To Implement]]></title><description><![CDATA[It's literally one DLL and two lines of code. No setup, no admin rights, no services.Just copy the single DLL into your project and reference it).using Secure_Store; // &lt;-- this namespace contains SecureStore class // Save anything JSON-serializable
SecureStore.Set("api_token", "super-secret-12345");
SecureStore.Set("user_settings", new UserPrefs { Theme = "Dark", Volume = 85 });
SecureStore.Set("last_window_pos", new int[] { 100, 200, 1280, 720 }); // Read it back (returns null/default if missing)
string? token = SecureStore.Get&lt;string&gt;("api_token"); UserPrefs? prefs = SecureStore.Get&lt;UserPrefs&gt;("user_settings");
if (prefs != null) Console.WriteLine($"Current theme: {prefs.Theme}"); int[]? pos = SecureStore.Get&lt;int[]&gt;("last_window_pos");
public record UserPrefs
{ public string Theme { get; set; } = "Light"; public int Volume { get; set; } = 50; public bool EnableHaptics { get; set; } = true;
}
Works perfectly with records, classes, anonymous types, lists, dictionaries — anything System.Text.Json can handle.// Save the privileged worker's local gRPC endpoint so the untrusted side can reconnect later
SecureStore.Set("worker_addr", "http://127.0.0.1:5050"); // Later, even after full app restart…
string? addr = SecureStore.Get&lt;string&gt;("worker_addr");
if (addr == null) throw new Exception("Secure worker address missing — something is very wrong"); var channel = Grpc.Net.Client.GrpcChannel.ForAddress(addr);
var client = MagicOnionClient.Create&lt;IPublicAcc&gt;(channel);
var info = await client.GetAccInfo(Environment.UserName);
]]></description><link>2.-how-to-implement.html</link><guid isPermaLink="false">2. How To Implement.md</guid><pubDate>Wed, 10 Dec 2025 02:29:08 GMT</pubDate></item><item><title><![CDATA[walkerdev]]></title><description><![CDATA[<img src="assets/walkerdev.png" target="_self">]]></description><link>assets/walkerdev.html</link><guid isPermaLink="false">Assets/walkerdev.png</guid><pubDate>Wed, 10 Dec 2025 02:15:42 GMT</pubDate><enclosure url="assets/walkerdev.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/walkerdev.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[kennaness]]></title><description><![CDATA[<img src="assets/kennaness.png" target="_self">]]></description><link>assets/kennaness.html</link><guid isPermaLink="false">Assets/kennaness.png</guid><pubDate>Wed, 10 Dec 2025 02:15:42 GMT</pubDate><enclosure url="assets/kennaness.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;assets/kennaness.png&quot;&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>